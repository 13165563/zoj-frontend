{
  "title": "两数之和",
  "content": "# 两数之和\n\n## 题目描述\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n## 示例\n\n示例 1：\n\n输入：`nums = [2,7,11,15]`, `target = 9`  \n输出：`[0,1]`  \n解释：因为 `nums[0] + nums[1] == 9`，返回 `[0, 1]`。\n\n示例 2：\n\n输入：`nums = [3,2,4]`, `target = 6`  \n输出：`[1,2]`\n\n示例 3：\n\n输入：`nums = [3,3]`, `target = 6`  \n输出：`[0,1]`\n\n## 提示\n\n- `2 <= nums.length <= 10^4`\n- `-10^9 <= nums[i] <= 10^9`\n- `-10^9 <= target <= 10^9`\n- 只会存在一个有效答案\n\n## 进阶\n\n你能想出一个时间复杂度小于 `O(n^2)` 的算法吗？\n\n## 解题思路\n\n使用哈希表来解决这个问题：\n\n1. 创建一个哈希表，用来存储已经遍历过的数字及其索引\n2. 遍历数组，对于每个数字，计算其与目标值的差值\n3. 检查差值是否已经在哈希表中存在：\n   - 如果存在，则找到了答案，返回两个数字的索引\n   - 如果不存在，将当前数字和索引存入哈希表\n4. 继续遍历直到找到答案\n\n时间复杂度：O(n)  \n空间复杂度：O(n)",
  "tags": ["数组", "哈希表", "算法"],
  "answer": "```java\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        \n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}\n```",
  "judgeCase": [
    {
      "input": "[2,7,11,15]\\n9",
      "output": "[0,1]"
    },
    {
      "input": "[3,2,4]\\n6",
      "output": "[1,2]"
    },
    {
      "input": "[3,3]\\n6",
      "output": "[0,1]"
    }
  ],
  "judgeConfig": {
    "timeLimit": 1000,
    "memoryLimit": 10000,
    "stackLimit": 10000
  }
}